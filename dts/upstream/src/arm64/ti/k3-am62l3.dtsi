// SPDX-License-Identifier: GPL-2.0-only or MIT
/*
 * Device Tree file for the AM62L3 SoC family (Dual Core A53)
 * Copyright (C) 2025 Texas Instruments Incorporated - https://www.ti.com/
 *
 * Technical Reference Manual: https://www.ti.com/lit/pdf/sprujb4
 */

/dts-v1/;

#include "k3-am62l.dtsi"

/ {
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu-map {
			cluster0: cluster0 {
				core0 {
					cpu = <&cpu0>;
				};

				core1 {
					cpu = <&cpu1>;
				};
			};
		};

		cpu0: cpu@0 {
			compatible = "arm,cortex-a53";
			reg = <0x000>;
			device_type = "cpu";
			enable-method = "psci";
			i-cache-size = <0x8000>;
			i-cache-line-size = <64>;
			i-cache-sets = <256>;
			d-cache-size = <0x8000>;
			d-cache-line-size = <64>;
			d-cache-sets = <128>;
			next-level-cache = <&l2_0>;
			operating-points-v2 = <&a53_opp_table>;
			clocks = <&scmi_clk 356>;
			power-domains = <&CPU_PD>;
			power-domain-names = "psci";
		};

		cpu1: cpu@1 {
			compatible = "arm,cortex-a53";
			reg = <0x001>;
			device_type = "cpu";
			enable-method = "psci";
			i-cache-size = <0x8000>;
			i-cache-line-size = <64>;
			i-cache-sets = <256>;
			d-cache-size = <0x8000>;
			d-cache-line-size = <64>;
			d-cache-sets = <128>;
			next-level-cache = <&l2_0>;
			operating-points-v2 = <&a53_opp_table>;
			clocks = <&scmi_clk 357>;
			power-domains = <&CPU_PD>;
			power-domain-names = "psci";
		};

		idle-states {
			entry-method = "psci";

			cpu_sleep_0: stby {
				compatible = "arm,idle-state";
				idle-state-name = "Standby";
				arm,psci-suspend-param = <0x00000001>;
				entry-latency-us = <25>;
				exit-latency-us = <100>;
				min-residency-us = <1000>;
			};
		};

		domain-idle-states {
			cluster_sleep_0: low-latency-stby {
				compatible = "domain-idle-state";
				arm,psci-suspend-param = <0x01000021>;
				entry-latency-us = <200>;
				exit-latency-us = <300>;
				min-residency-us = <10000>;
			};
		};
	};

	l2_0: l2-cache0 {
		compatible = "cache";
		cache-unified;
		cache-level = <2>;
		cache-size = <0x40000>;
		cache-line-size = <64>;
		cache-sets = <256>;
	};

	a53_opp_table: opp-table {
		compatible = "operating-points-v2-ti-cpu";
		opp-shared;
		syscon = <&opp_efuse_table>;

		opp-200000000 {
			opp-hz = /bits/ 64 <200000000>;
			opp-supported-hw = <0x01 0x0003>;
			clock-latency-ns = <6000000>;
		};

		opp-400000000 {
			opp-hz = /bits/ 64 <400000000>;
			opp-supported-hw = <0x01 0x0003>;
			clock-latency-ns = <6000000>;
		};

		opp-600000000 {
			opp-hz = /bits/ 64 <600000000>;
			opp-supported-hw = <0x01 0x0003>;
			clock-latency-ns = <6000000>;
		};

		opp-800000000 {
			opp-hz = /bits/ 64 <800000000>;
			opp-supported-hw = <0x01 0x0003>;
			clock-latency-ns = <6000000>;
		};

		opp-1000000000 {
			opp-hz = /bits/ 64 <1000000000>;
			opp-supported-hw = <0x01 0x0002>;
			clock-latency-ns = <6000000>;
		};

		opp-1250000000 {
			opp-hz = /bits/ 64 <1250000000>;
			opp-supported-hw = <0x01 0x0002>;
			clock-latency-ns = <6000000>;
			opp-suspend;
		};
	};
};
/*
 * HACK : Adding DSS driver under the Cluster PD
 * The standby state puts DDR in Auto Self Refresh, however due to a bug in DDR Auto self refresh
 * when the display is active, DSS driver faces Plane Underflow and SYNC_LOST errors.
 * This is a workaround to prevent entry into standby when the display is active.
 */
&scmi_pds {
	power-domain-map = <39 &CLUSTER_PD>, /* DSS0 */
			   <38 &CLUSTER_PD>; /* DSS_DSI0 */
};

&psci {
	CPU_PD: power-controller-cpu {
		#power-domain-cells = <0>;
		power-domains = <&CLUSTER_PD>;
		domain-idle-states = <&cpu_sleep_0>;
	};

	CLUSTER_PD: power-controller-cluster {
		#power-domain-cells = <0>;
		domain-idle-states = <&cluster_sleep_0>;
	};
};
